-- LocalScript in StarterPlayerScripts
-- Single Config table for defaults and behavior
-- Updated: Rayfield tabs + friendly price parsing/formatting (100b / 100bil / 100 billion / 1.5m / 5k)
-- UI tabs: Skipping, Purchase, Selected, Secrets, AutoFarm
-- Hidden TextBoxes preserved for compatibility with existing logic if Rayfield fails to load.
-- Fix: safe Set calls for Rayfield controls to avoid nil:Set errors.
-- Default MinPrice changed to 10,000,000,000 (10 billion)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local guiParent = player:WaitForChild("PlayerGui")

-- Configuration (single source of truth for defaults)
local Config = {
    MinPrice = 25000000000,          -- 25B (default minimum price)
    MaxPrice = 100000000000,         -- 100B (highest)
    SkipInterval = 0.5,              -- seconds between confirmed-skip requests (legacy)
    FastSkipInterval = 0.01,         -- seconds between fast skip requests (no confirmedSkip)
    FastSkipDetectDuration = 0.5,    -- seconds an egg must persist before firing confirmedSkip
    ResumeDelay = 1.0,               -- seconds to resume skipping after purchase
    PurchaseDebounce = 0.05,         -- minimum seconds between purchases per egg
    EventAutoBuyDefault = true,      -- Auto Buy During Event default (default ON)
    AutoSpecialDefault = true,       -- Auto Buy Admin/Developer/Exclusive/Limited default
    MiniButtonDefaultPos = UDim2.new(0.9, 0, 0.9, 0)
}

-- Safe remotes lookup (best-effort)
local purchaseEvent, requestEvent, collectEvent, sellEvent
do
    local modules = ReplicatedStorage:FindFirstChild("Modules")
    local internals = modules and modules:FindFirstChild("Internals")
    local skeleton = internals and internals:FindFirstChild("Skeleton")
    local conduit = skeleton and skeleton:FindFirstChild("Conduit")
    local instances = conduit and conduit:FindFirstChild("Instances")
    purchaseEvent = instances and instances:FindFirstChild("_purchaseEgg")
    requestEvent = instances and instances:FindFirstChild("_requestEgg")
    collectEvent = instances and instances:FindFirstChild("_collectEarnings")
    sellEvent = instances and instances:FindFirstChild("_sellStack")
end

-- Hidden GUI container for compatibility (script uses these TextBoxes elsewhere)
local hiddenGui = Instance.new("ScreenGui")
hiddenGui.Name = "AutoHiddenGui"
hiddenGui.ResetOnSpawn = false
hiddenGui.Enabled = false
hiddenGui.Parent = guiParent

-- Formatting helpers
local function formatWithCommasPreserveDecimals(num)
    if num == nil then return "" end
    local negative = false
    if num < 0 then negative = true; num = -num end
    local s = tostring(num)
    local intPart, fracPart = s:match("^(%d+)(%.%d+)$")
    if not intPart then intPart = s:match("^(%d+)$") or "0"; fracPart = s:match("^%d+(%.%d+)$") or "" end
    local result = ""
    while #intPart > 3 do
        local tail = intPart:sub(-3)
        result = "," .. tail .. result
        intPart = intPart:sub(1, -4)
    end
    result = intPart .. result
    if fracPart and fracPart ~= "" then result = result .. fracPart end
    if negative then result = "-" .. result end
    return result
end

-- Parse friendly number strings like "100b", "100bil", "100 billion", "1.5m", "2k", or plain numeric with commas.
local function parseFriendlyNumber(text)
    if not text then return nil end
    local s = tostring(text)
    s = s:lower()
    s = s:gsub("%$", "")
    s = s:gsub(",", "")
    s = s:gsub("%s+", "")
    if s == "" then return nil end

    local mult = 1
    if s:match("billion$") or s:match("bil$") or s:match("b$") then
        mult = 1e9
        s = s:gsub("billion$", ""):gsub("bil$", ""):gsub("b$", "")
    elseif s:match("million$") or s:match("mil$") or s:match("m$") then
        mult = 1e6
        s = s:gsub("million$", ""):gsub("mil$", ""):gsub("m$", "")
    elseif s:match("thousand$") or s:match("k$") then
        mult = 1e3
        s = s:gsub("thousand$", ""):gsub("k$", "")
    end

    local n = tonumber(s)
    if not n then return nil end
    return n * mult
end

-- old numeric extractor used for intervals (keeps previous behavior)
local function extractNumeric(str)
    if not str then return nil end
    local clean = str:gsub("[^%d%.%-]", "")
    local firstDot = clean:find("%.")
    if firstDot then clean = clean:sub(1, firstDot) .. clean:sub(firstDot):gsub("%.", "") end
    clean = clean:gsub("%-(.+)%-", "%1")
    return tonumber(clean)
end

local function bindFormatting(box)
    if not box then return end
    box:GetPropertyChangedSignal("Text"):Connect(function()
        local n = extractNumeric(box.Text)
        if n ~= nil then box:SetAttribute("NumericValue", n) end
    end)
    box.FocusLost:Connect(function()
        local n = box:GetAttribute("NumericValue")
        if n ~= nil and n ~= "" then box.Text = formatWithCommasPreserveDecimals(n) end
    end)
end

-- Create hidden TextBoxes that script uses
local function makeHiddenBox(name, defaultText, numericDefault, alignRight)
    local tb = Instance.new("TextBox")
    tb.Name = name
    tb.Size = UDim2.new(0, 200, 0, 20)
    tb.Position = UDim2.new(0, 0, 0, 0)
    tb.BackgroundTransparency = 1
    tb.TextColor3 = Color3.fromRGB(255,255,255)
    tb.ClearTextOnFocus = false
    tb.Text = tostring(defaultText or "")
    tb:SetAttribute("NumericValue", numericDefault)
    tb.TextXAlignment = alignRight and Enum.TextXAlignment.Right or Enum.TextXAlignment.Left
    tb.Font = Enum.Font.SourceSans
    tb.TextSize = 14
    tb.Visible = false
    tb.Parent = hiddenGui
    return tb
end

local minBox = makeHiddenBox("MinPriceBox", formatWithCommasPreserveDecimals(Config.MinPrice), Config.MinPrice, true)
local maxBox = makeHiddenBox("MaxPriceBox", formatWithCommasPreserveDecimals(Config.MaxPrice), Config.MaxPrice, true)
local skipBox = makeHiddenBox("SkipIntervalBox", tostring(Config.SkipInterval), Config.SkipInterval, true)
local fastSkipBox = makeHiddenBox("FastSkipIntervalBox", tostring(Config.FastSkipInterval), Config.FastSkipInterval, true)
local fastDetectBox = makeHiddenBox("FastSkipDetectBox", tostring(Config.FastSkipDetectDuration), Config.FastSkipDetectDuration, true)
local delayBox = makeHiddenBox("ResumeDelayBox", tostring(Config.ResumeDelay), Config.ResumeDelay, true)

local selectedEggBox = makeHiddenBox("SelectedEggBox", "", nil, false)
local selectedVarietyBox = makeHiddenBox("SelectedVarietyBox", "", nil, false)
local secretVarietyInput = makeHiddenBox("SecretVarietyInputBox", "Glitch,Galaxy", nil, false) -- default Glitch,Galaxy

local status = Instance.new("TextBox")
status.Name = "StatusLabel"
status.Size = UDim2.new(0,200,0,20)
status.BackgroundTransparency = 1
status.TextColor3 = Color3.fromRGB(200,200,200)
status.Text = "Status: Idle"
status.Font = Enum.Font.SourceSans
status.TextSize = 13
status.TextXAlignment = Enum.TextXAlignment.Left
status.Visible = false
status.Parent = hiddenGui

-- Bind numeric formatting (for intervals)
for _, b in ipairs({minBox, maxBox, skipBox, delayBox, fastSkipBox, fastDetectBox}) do
    bindFormatting(b)
end

-- parse utilities for names/varieties
local function parseVarietyInput(text)
    if not text then return {} end
    local set = {}
    for part in string.gmatch(text, "[^,]+") do
        local trimmed = part:gsub("^%s+", ""):gsub("%s+$", "")
        if trimmed ~= "" then
            set[trimmed:lower()] = true
        end
    end
    return set
end

local function parseSelectedNames(text)
    local list = {}
    if not text then return list end
    for part in string.gmatch(text, "[^,]+") do
        local trimmed = part:gsub("^%s+", ""):gsub("%s+$", "")
        if trimmed ~= "" then
            table.insert(list, trimmed:lower())
        end
    end
    return list
end

-- State
local autoBuyEnabled = false
local skipEnabled = false
local autoFarmEnabled = false
local selectedEggEnabled = false
local autoSpecialEnabled = Config.AutoSpecialDefault

local eventAutoBuyEnabled = Config.EventAutoBuyDefault
local eventForceOn = false
local eventPrevAutoBuy = false

local PURCHASE_DEBOUNCE = Config.PurchaseDebounce
local lastFireById = {}

-- Fast-skip tracking
local trackedPriceLabel = nil
local trackedSince = 0
local lastConfirmedSkipAt = 0

-- Purchase helpers (unchanged)
local function parsePriceLabel(raw)
    if not raw or raw == "" then return nil end
    local s = raw:lower():gsub("%$", ""):gsub(",", ""):gsub("%s+", "")
    local mult = 1
    if s:match("k$") then mult = 1000; s = s:gsub("k$", "") end
    if s:match("m$") then mult = 1000000; s = s:gsub("m$", "") end
    if s:match("b$") then mult = 1000000000; s = s:gsub("b$", "") end
    local n = tonumber(s)
    if not n then return nil end
    return n * mult
end

local function firePurchase(label)
    if not label or not label.Parent then return end
    local containerLabel = label.Parent
    local rarityLabel = containerLabel:FindFirstChild("Rarity")
    local varietyLabel = containerLabel:FindFirstChild("Variety")
    local rarity = rarityLabel and rarityLabel:IsA("TextLabel") and rarityLabel.Text or "Unknown"
    local variety = varietyLabel and varietyLabel:IsA("TextLabel") and varietyLabel.Text or "Default"
    local modelAncestor = label:FindFirstAncestorWhichIsA("Model")
    if not modelAncestor then return end
    local eggId = "entity_" .. modelAncestor.Name .. "_egg"

    local now = os.clock()
    if lastFireById[eggId] and (now - lastFireById[eggId]) < PURCHASE_DEBOUNCE then return end
    lastFireById[eggId] = now

    -- Stop skipping immediately
    skipEnabled = false
    status.Text = "Status: Purchasing..."

    local args = {
        [1] = {
            ["__raw"] = true,
            ["data"] = {
                ["id"] = eggId,
                ["rarity"] = rarity,
                ["variety"] = variety
            }
        }
    }
    if purchaseEvent then
        pcall(function() purchaseEvent:FireServer(unpack(args)) end)
    end

    -- Resume skip spam after configurable delay (default from Config)
    local resumeDelay = delayBox:GetAttribute("NumericValue") or Config.ResumeDelay
    if type(resumeDelay) ~= "number" then resumeDelay = tonumber(resumeDelay) or Config.ResumeDelay end
    task.delay(resumeDelay, function()
        if autoBuyEnabled then
            skipEnabled = true
            status.Text = "Status: Skipping..."
        else
            status.Text = "Status: Idle"
        end
    end)
end

-- selected egg matching (multi-name partial) and variety whitelist
local function matchesSelectedEgg(label)
    local names = parseSelectedNames(selectedEggBox.Text)
    if #names == 0 then return false end

    local modelAncestor = label:FindFirstAncestorWhichIsA("Model")
    if modelAncestor then
        local mname = tostring(modelAncestor.Name):lower()
        for _, n in ipairs(names) do
            if mname:find(n, 1, true) then return true end
        end
    end

    local containerLabel = label.Parent
    if containerLabel then
        for _, child in ipairs(containerLabel:GetChildren()) do
            if child:IsA("TextLabel") then
                local txt = tostring(child.Text or ""):lower()
                for _, n in ipairs(names) do
                    if txt:find(n, 1, true) then return true end
                end
            end
        end
    end
    return false
end

local function matchesSelectedVariety(label)
    if not label or not label.Parent then return true end
    local set = parseVarietyInput(selectedVarietyBox.Text)
    if next(set) == nil then return true end
    local containerLabel = label.Parent
    local varietyLabel = containerLabel:FindFirstChild("Variety")
    if not varietyLabel or not varietyLabel:IsA("TextLabel") then return true end
    local varText = tostring(varietyLabel.Text or ""):gsub("^%s+", ""):gsub("%s+$", ""):lower()
    return set[varText] == true
end

-- rarity helpers
local function getRarityText(label)
    if not label or not label.Parent then return "" end
    local containerLabel = label.Parent
    local rarityLabel = containerLabel:FindFirstChild("Rarity")
    if not rarityLabel or not rarityLabel:IsA("TextLabel") then return "" end
    return tostring(rarityLabel.Text or ""):lower()
end

local function isSecretRarity(label) return getRarityText(label) == "secret" end
local function isExclusiveRarity(label) return getRarityText(label) == "exclusive" end
local function isLimitedRarity(label) return getRarityText(label) == "limited" end
local function isAdminRarity(label) return getRarityText(label) == "admin" end
local function isDeveloperRarity(label) return getRarityText(label) == "developer" end

local function matchesSecretVariety(label)
    if not label or not label.Parent then return false end
    if not isSecretRarity(label) then return false end
    local containerLabel = label.Parent
    local varietyLabel = containerLabel:FindFirstChild("Variety")
    if not varietyLabel or not varietyLabel:IsA("TextLabel") then return true end
    local varText = tostring(varietyLabel.Text or ""):gsub("^%s+", ""):gsub("%s+$", ""):lower()
    local set = parseVarietyInput(secretVarietyInput.Text)
    if next(set) == nil then return true end
    return set[varText] == true
end

-- price handling (priority: selected, special rarities, secret price/variety, normal price)
local function handlePriceLabel(label)
    if not label or not label:IsA("TextLabel") or label.Name ~= "Price" then return end

    local function startTracking()
        trackedPriceLabel = label
        trackedSince = os.clock()
    end
    local function onTextChanged()
        trackedPriceLabel = label
        trackedSince = os.clock()
    end

    local function check()
        if selectedEggEnabled and matchesSelectedEgg(label) and matchesSelectedVariety(label) then
            firePurchase(label); return
        end

        if autoSpecialEnabled and (isExclusiveRarity(label) or isLimitedRarity(label) or isAdminRarity(label) or isDeveloperRarity(label)) then
            firePurchase(label); return
        end

        if not autoBuyEnabled then return end
        local value = parsePriceLabel(label.Text)
        local minVal = minBox:GetAttribute("NumericValue") or extractNumeric(minBox.Text) or 0
        local maxVal = maxBox:GetAttribute("NumericValue") or extractNumeric(maxBox.Text) or math.huge
        if not value then return end

        if isSecretRarity(label) then
            if matchesSecretVariety(label) and value >= minVal and value <= maxVal then firePurchase(label) end
            return
        end

        if value >= minVal and value <= maxVal then firePurchase(label) end
    end

    startTracking()
    check()
    label:GetPropertyChangedSignal("Text"):Connect(function() onTextChanged(); pcall(check) end)
end

local function setupContainer(containerObj)
    for _, child in ipairs(containerObj:GetChildren()) do
        if child:IsA("TextLabel") and child.Name == "Price" then handlePriceLabel(child) end
    end
    containerObj.ChildAdded:Connect(function(child)
        if child:IsA("TextLabel") and child.Name == "Price" then handlePriceLabel(child) end
    end)
end

local function setupEggtag(eggtag)
    local c = eggtag:FindFirstChild("Container") or eggtag:WaitForChild("Container", 10)
    if c then setupContainer(c) end
end

for _, inst in ipairs(Workspace:GetDescendants()) do
    if inst.Name == "Eggtag" then setupEggtag(inst) end
end

Workspace.DescendantAdded:Connect(function(inst)
    if inst.Name == "Eggtag" then setupEggtag(inst)
    elseif inst.Name == "Price" and inst:IsA("TextLabel") then handlePriceLabel(inst) end
end)

-- Event labels monitoring
local eventBoard = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Essentials")
eventBoard = eventBoard and eventBoard:FindFirstChild("EventBoard")
local surfaceGui = eventBoard and eventBoard:FindFirstChild("SurfaceGui")
local glitchLabel = surfaceGui and surfaceGui:FindFirstChild("Glitch")
local galaxyLabel = surfaceGui and surfaceGui:FindFirstChild("Galaxy")

local function isLabelActive(lbl)
    if not lbl or not lbl:IsA("TextLabel") then return false end
    local ok, txt = pcall(function() return tostring(lbl.Text or "") end)
    if not ok then return false end
    txt = txt:lower()
    return txt:find("event is active", 1, true) ~= nil
end

function checkEventLabelsAndApply()
    if not eventAutoBuyEnabled then return end
    local active = false
    if isLabelActive(glitchLabel) then active = true end
    if isLabelActive(galaxyLabel) then active = true end

    if active and not eventForceOn then
        eventPrevAutoBuy = autoBuyEnabled
        eventForceOn = true
        autoBuyEnabled = true
        skipEnabled = true
        status.Text = "Status: Event active - Auto Buy ON"
    elseif not active and eventForceOn then
        eventForceOn = false
        autoBuyEnabled = eventPrevAutoBuy
        skipEnabled = autoBuyEnabled
        status.Text = autoBuyEnabled and "Status: Auto Buy ON" or "Status: Idle"
    end
end

if glitchLabel and glitchLabel:IsA("TextLabel") then
    glitchLabel:GetPropertyChangedSignal("Text"):Connect(function() pcall(checkEventLabelsAndApply) end)
end
if galaxyLabel and galaxyLabel:IsA("TextLabel") then
    galaxyLabel:GetPropertyChangedSignal("Text"):Connect(function() pcall(checkEventLabelsAndApply) end)
end

pcall(function() checkEventLabelsAndApply() end)

-- Helper to fire requestEvent safely
local function fireRequestEgg(argsTable)
    if requestEvent then
        pcall(function() requestEvent:FireServer(unpack(argsTable)) end)
    else
        local ok, conduit = pcall(function()
            return ReplicatedStorage.Modules.Internals.Skeleton.Conduit.Instances
        end)
        if ok and conduit and conduit:FindFirstChild("_requestEgg") then
            pcall(function() conduit._requestEgg:FireServer(unpack(argsTable)) end)
        end
    end
end

-- Robust helper to call collect/sell remotes (tries cached var first, then resolves by name)
local function tryFire(actionName, cachedRemote)
    local args = { [1] = { ["__raw"] = true, ["data"] = {} } }
    if cachedRemote then
        local ok, err = pcall(function() cachedRemote:FireServer(unpack(args)) end)
        if ok then return true end
    end
    -- fallback resolution
    local ok, conduit = pcall(function()
        return ReplicatedStorage.Modules.Internals.Skeleton.Conduit.Instances
    end)
    if ok and conduit then
        local remote = conduit:FindFirstChild(actionName)
        if remote then
            local ok2 = pcall(function() remote:FireServer(unpack(args)) end)
            if ok2 then
                -- update cache for future
                if actionName == "_collectEarnings" then collectEvent = remote end
                if actionName == "_sellStack" then sellEvent = remote end
                return true
            end
        end
    end
    return false
end

local function fireCollect()
    local ok = tryFire("_collectEarnings", collectEvent)
    return ok
end
local function fireSell()
    local ok = tryFire("_sellStack", sellEvent)
    return ok
end

-- Skip spam loop
task.spawn(function()
    while true do
        local fastInterval = fastSkipBox:GetAttribute("NumericValue") or Config.FastSkipInterval
        if type(fastInterval) ~= "number" then fastInterval = tonumber(fastInterval) or Config.FastSkipInterval end
        local detectDuration = fastDetectBox:GetAttribute("NumericValue") or Config.FastSkipDetectDuration
        if type(detectDuration) ~= "number" then detectDuration = tonumber(detectDuration) or Config.FastSkipDetectDuration end
        local confirmedInterval = skipBox:GetAttribute("NumericValue") or Config.SkipInterval
        if type(confirmedInterval) ~= "number" then confirmedInterval = tonumber(confirmedInterval) or Config.SkipInterval end

        if autoBuyEnabled and skipEnabled then
            local now = os.clock()
            local shouldFireConfirmed = false

            if trackedPriceLabel and trackedSince and (now - trackedSince) >= detectDuration then
                if (now - lastConfirmedSkipAt) >= math.max(0.05, detectDuration) then
                    shouldFireConfirmed = true
                    lastConfirmedSkipAt = now
                end
            end

            if shouldFireConfirmed then
                local args = { [1] = { ["__raw"] = true, ["data"] = { ["confirmedSkip"] = true } } }
                fireRequestEgg(args)
                status.Text = "Status: Confirmed Skip Sent"
                task.wait(confirmedInterval)
            else
                local args = { [1] = { ["__raw"] = true, ["data"] = {} } }
                fireRequestEgg(args)
                status.Text = "Status: Fast Skipping..."
                task.wait(math.max(0.001, fastInterval))
            end
        else
            task.wait(0.1)
        end
    end
end)

-- AutoFarm helpers
local function equipBoxStackTool()
    local backpack = player:FindFirstChild("Backpack")
    if not backpack then return false end
    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") and tostring(item.Name):match("^Box Stack %[") then
            if player.Character then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then pcall(function() humanoid:EquipTool(item) end); return true end
            end
        end
    end
    return false
end
local function isBoxStackEquipped()
    if not player.Character then return false end
    local equippedTool = player.Character:FindFirstChildOfClass("Tool")
    if not equippedTool then return false end
    return tostring(equippedTool.Name):match("^Box Stack %[") ~= nil
end

task.spawn(function()
    while true do
        if autoFarmEnabled then
            status.Text = "Status: Auto Farm active"
            local equipped = equipBoxStackTool()
            local collected = fireCollect()
            if collected then
                status.Text = "Status: Collected"
            else
                status.Text = "Status: Collect failed"
            end
            -- Only fire sell if equipped or successfully equipped
            if equipped or isBoxStackEquipped() then
                local sold = fireSell()
                if sold then
                    status.Text = "Status: Sold"
                else
                    status.Text = "Status: Sell failed"
                end
            end
            task.wait(1)
        else
            task.wait(0.25)
        end
    end
end)

-- Rayfield UI creation (tabbed)
local function safeLoadRayfield(url)
    local ok, lib = pcall(function()
        local src = game:HttpGet(url)
        local fn = loadstring(src)
        return fn()
    end)
    if ok then return lib end
    warn("Rayfield load failed:", lib)
    return nil
end

local Rayfield = safeLoadRayfield("https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/main/source.lua")
if Rayfield then
    local Window = Rayfield:CreateWindow({
        Name = "MyAnimeEggFarm",
        LoadingTitle = "MyAnimeEggFarm",
        LoadingSubtitle = "Auto Controls",
        ConfigurationSaving = { Enabled = false }
    })

    -- helper: safely call :Set on a Rayfield control if it exists
    local function safeSet(ctrl, value)
        if ctrl and type(ctrl.Set) == "function" then
            pcall(function() ctrl:Set(value) end)
        end
    end

    -- Skipping tab
    local SkipTab = Window:CreateTab("Skipping", 4483362458)
    SkipTab:CreateSection("Skip Timing")
    local skipInput = SkipTab:CreateInput({
        Name = "Skip Interval (confirmed)",
        Info = "seconds between confirmed-skip",
        PlaceholderText = tostring(Config.SkipInterval),
        CurrentValue = tostring(skipBox:GetAttribute("NumericValue") or Config.SkipInterval),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            skipBox.Text = text or ""
            local n = extractNumeric(text)
            if n then
                skipBox:SetAttribute("NumericValue", n)
                safeSet(skipInput, formatWithCommasPreserveDecimals(n))
            end
        end
    })
    local fastInput = SkipTab:CreateInput({
        Name = "Fast Skip Interval",
        Info = "seconds between fast skip",
        PlaceholderText = tostring(Config.FastSkipInterval),
        CurrentValue = tostring(fastSkipBox:GetAttribute("NumericValue") or Config.FastSkipInterval),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            fastSkipBox.Text = text or ""
            local n = extractNumeric(text)
            if n then
                fastSkipBox:SetAttribute("NumericValue", n)
                safeSet(fastInput, tostring(n))
            end
        end
    })
    local detectInput = SkipTab:CreateInput({
        Name = "Fast Skip Detect Duration",
        Info = "when persistent -> confirmedSkip",
        PlaceholderText = tostring(Config.FastSkipDetectDuration),
        CurrentValue = tostring(fastDetectBox:GetAttribute("NumericValue") or Config.FastSkipDetectDuration),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            fastDetectBox.Text = text or ""
            local n = extractNumeric(text)
            if n then
                fastDetectBox:SetAttribute("NumericValue", n)
                safeSet(detectInput, tostring(n))
            end
        end
    })
    local resumeInput = SkipTab:CreateInput({
        Name = "Resume Delay",
        Info = "seconds to resume skipping after purchase",
        PlaceholderText = tostring(Config.ResumeDelay),
        CurrentValue = tostring(delayBox:GetAttribute("NumericValue") or Config.ResumeDelay),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            delayBox.Text = text or ""
            local n = extractNumeric(text)
            if n then
                delayBox:SetAttribute("NumericValue", n)
                safeSet(resumeInput, tostring(n))
            end
        end
    })

    -- Purchase tab
    local PurchaseTab = Window:CreateTab("Purchase", 4483362458)
    PurchaseTab:CreateSection("Price Limits")
    local minInput = PurchaseTab:CreateInput({
        Name = "Min Price",
        Info = "e.g. 1b, 100m, 5000000, or just numbers",
        PlaceholderText = tostring(Config.MinPrice),
        CurrentValue = formatWithCommasPreserveDecimals(minBox:GetAttribute("NumericValue") or Config.MinPrice),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            if not text then return end
            local n = parseFriendlyNumber(text)
            if n then
                minBox:SetAttribute("NumericValue", n)
                minBox.Text = formatWithCommasPreserveDecimals(n)
                safeSet(minInput, formatWithCommasPreserveDecimals(n))
            else
                local q = extractNumeric(text)
                if q then
                    minBox:SetAttribute("NumericValue", q)
                    minBox.Text = formatWithCommasPreserveDecimals(q)
                    safeSet(minInput, formatWithCommasPreserveDecimals(q))
                else
                    minBox.Text = text
                    safeSet(minInput, text)
                end
            end
        end
    })
    local maxInput = PurchaseTab:CreateInput({
        Name = "Max Price",
        Info = "e.g. 100b, 50m, 1e9, or numbers",
        PlaceholderText = tostring(Config.MaxPrice),
        CurrentValue = formatWithCommasPreserveDecimals(maxBox:GetAttribute("NumericValue") or Config.MaxPrice),
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            if not text then return end
            local n = parseFriendlyNumber(text)
            if n then
                maxBox:SetAttribute("NumericValue", n)
                maxBox.Text = formatWithCommasPreserveDecimals(n)
                safeSet(maxInput, formatWithCommasPreserveDecimals(n))
            else
                local q = extractNumeric(text)
                if q then
                    maxBox:SetAttribute("NumericValue", q)
                    maxBox.Text = formatWithCommasPreserveDecimals(q)
                    safeSet(maxInput, formatWithCommasPreserveDecimals(q))
                else
                    maxBox.Text = text
                    safeSet(maxInput, text)
                end
            end
        end
    })

    PurchaseTab:CreateSection("Purchase Behavior")
    PurchaseTab:CreateToggle({
        Name = "Auto Buy",
        CurrentValue = autoBuyEnabled,
        Flag = "AutoBuyToggle",
        Callback = function(val) autoBuyEnabled = val; skipEnabled = val; status.Text = val and "Status: Auto Buy ON" or "Status: Idle" end
    })
    PurchaseTab:CreateToggle({
        Name = "Auto Buy Special Rarities",
        CurrentValue = autoSpecialEnabled,
        Flag = "AutoSpecialToggle",
        Callback = function(val) autoSpecialEnabled = val; status.Text = val and "Status: Auto Buy Special ON" or "Status: Idle" end
    })
    PurchaseTab:CreateToggle({
        Name = "Auto Buy During Event",
        CurrentValue = eventAutoBuyEnabled,
        Flag = "EventAutoBuyToggle",
        Callback = function(val)
            eventAutoBuyEnabled = val
            status.Text = val and "Status: Event watch ON" or "Status: Idle"
            if eventAutoBuyEnabled then pcall(function() checkEventLabelsAndApply() end) else
                if eventForceOn then eventForceOn = false; autoBuyEnabled = eventPrevAutoBuy; skipEnabled = autoBuyEnabled; status.Text = autoBuyEnabled and "Status: Auto Buy ON" or "Status: Idle" end
            end
        end
    })

    -- Selected tab
    local SelectedTab = Window:CreateTab("Selected", 4483362458)
    SelectedTab:CreateSection("Selected Egg Settings")
    local selNames = SelectedTab:CreateInput({
        Name = "Selected Egg Names",
        Info = "Comma-separated partial names (matches any)",
        PlaceholderText = "",
        CurrentValue = selectedEggBox.Text or "",
        RemoveTextAfterFocusLost = false,
        Callback = function(text) selectedEggBox.Text = text or "" end
    })
    local selVars = SelectedTab:CreateInput({
        Name = "Selected Varieties",
        Info = "Comma-separated exact variety names (leave empty to allow any)",
        PlaceholderText = "",
        CurrentValue = selectedVarietyBox.Text or "",
        RemoveTextAfterFocusLost = false,
        Callback = function(text) selectedVarietyBox.Text = text or "" end
    })
    SelectedTab:CreateToggle({
        Name = "Auto Buy Selected",
        CurrentValue = selectedEggEnabled,
        Flag = "AutoBuySelectedToggle",
        Callback = function(val) selectedEggEnabled = val; status.Text = val and "Status: Auto Buy Selected ON" or "Status: Idle" end
    })

    -- Secrets tab
    local SecretsTab = Window:CreateTab("Secrets", 4483362458)
    SecretsTab:CreateSection("Secret Varieties & Events")
    local secretInput = SecretsTab:CreateInput({
        Name = "Secret Varieties",
        Info = "Comma-separated (default: Glitch,Galaxy). Only Secret eggs with these varieties will be bought (and must meet price limits).",
        PlaceholderText = "Glitch,Galaxy",
        CurrentValue = secretVarietyInput.Text or "Glitch,Galaxy",
        RemoveTextAfterFocusLost = false,
        Callback = function(text) secretVarietyInput.Text = text or "" end
    })
    SecretsTab:CreateButton({ Name = "Check Event State Now", Callback = function() pcall(function() checkEventLabelsAndApply() end) end })

    -- AutoFarm tab
    local FarmTab = Window:CreateTab("AutoFarm", 4483362458)
    FarmTab:CreateSection("AutoFarm")
    FarmTab:CreateToggle({
        Name = "Auto Farm (collect/sell/equip loop)",
        CurrentValue = autoFarmEnabled,
        Flag = "AutoFarmToggle",
        Callback = function(val) autoFarmEnabled = val; status.Text = val and "Status: Auto Farm ON" or "Status: Idle" end
    })
    FarmTab:CreateButton({ Name = "Collect Now", Callback = function() local ok = fireCollect(); status.Text = ok and "Status: Collected" or "Status: Collect failed" end })
    FarmTab:CreateButton({ Name = "Sell Now", Callback = function() local ok = fireSell(); status.Text = ok and "Status: Sold" or "Status: Sell failed" end })

    -- Update hidden boxes to formatted values (in case Rayfield didn't)
    minBox.Text = formatWithCommasPreserveDecimals(minBox:GetAttribute("NumericValue") or Config.MinPrice)
    maxBox.Text = formatWithCommasPreserveDecimals(maxBox:GetAttribute("NumericValue") or Config.MaxPrice)
    skipBox.Text = tostring(skipBox:GetAttribute("NumericValue") or Config.SkipInterval)
    fastSkipBox.Text = tostring(fastSkipBox:GetAttribute("NumericValue") or Config.FastSkipInterval)
    fastDetectBox.Text = tostring(fastDetectBox:GetAttribute("NumericValue") or Config.FastSkipDetectDuration)
    delayBox.Text = tostring(delayBox:GetAttribute("NumericValue") or Config.ResumeDelay)
else
    warn("Rayfield failed to load â€” UI disabled. Use hidden values or edit script to change settings.")
end

-- Ensure defaults persisted
minBox:SetAttribute("NumericValue", minBox:GetAttribute("NumericValue") or Config.MinPrice)
maxBox:SetAttribute("NumericValue", maxBox:GetAttribute("NumericValue") or Config.MaxPrice)
skipBox:SetAttribute("NumericValue", skipBox:GetAttribute("NumericValue") or Config.SkipInterval)
fastSkipBox:SetAttribute("NumericValue", fastSkipBox:GetAttribute("NumericValue") or Config.FastSkipInterval)
fastDetectBox:SetAttribute("NumericValue", fastDetectBox:GetAttribute("NumericValue") or Config.FastSkipDetectDuration)
delayBox:SetAttribute("NumericValue", delayBox:GetAttribute("NumericValue") or Config.ResumeDelay)
status.Text = "Status: Idle"
